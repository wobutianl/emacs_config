#+TITLE: Facts and Fallacies of Software Engineering读书笔记
#+AUTHOR: zhuxiaolin

这本书大体介绍下，就是现在争论比较多的一些软件开发的原则。

一些是事实的，一些是谬误的。

只有做过开发的才比较清楚。现在学一学，对自己有一定的好处，尤其是在工具，技术，等的理解上。

所有的一切到最后都是归结为：人。

人才是软件的创造，理解，使用者。软件是为人所服务的。
现在只是把他里面的东西给汉化而已。
* Facts
** management
- the most important factor in software work, is not the tools and techniques
 used by the programmar ,but rather the quality of the programmers themselves
  - 编码最重要的是人！
- The best programmers are up to 28 times better than the worst programmers, according to "individual differences" research. Given that their pay is never commensurate, they are the biggest bargains in the software field.
  - 好，坏程序员差距28倍
- Adding people to a late project makes it later.
  - 在项目结束时加新人，会推迟项目
- Hype is the plague on the house of software. Most software tool and technique improvements account for about a 5 to 35 percent increase in productivity and quality. But at one time or another, most of those same improvements have been claimed by someone to have "order of magnitude" benefits.
  - 工具和技术可能有25%的效率提升，但不可能数量级的提升。
- Learning a new tool or technique actually lowers programmer productivity and product quality initially. The eventual benefit is achieved only after this learning curve is overcome. Therefore, it is worth adopting new tools and techniques, but only (a) if their value is seen realistically and (b) if patience is used in measuring benefits.
  - 工具真正有用是在度过了学习曲线之后。
- Software developers talk a lot about tools. They evaluate quite a few, buy a fair number, and use practically none.
  - 工具说多了没用，要真正使用
- One of the two most common causes of runaway projects is poor estimation.
  - 程序失控通常因为：不良的估计。
- Most software estimates are performed at the beginning of the life cycle. This makes sense until we realize that estimates are obtained before the requirements are defined and thus before the problem is understood. Estimation, therefore, usually occurs at the wrong time.
  - 要在项目开始后估计时间。
- Software estimates are rarely adjusted as the project proceeds. Thus those estimates done at the wrong time by the wrong people are usually not corrected.
  - 项目时长被错误的人估计
- Since estimates are so faulty, there is little reason to be concerned when software projects do not meet estimated targets. But everyone is concerned anyway.
  - 
- There is a disconnect between management and their programmers. In one research study of a project that failed to meet its estimates and was seen by its management as a failure, the technical participants saw it as the most successful project they had ever worked on.
  - 管理者与程序员缺少沟通
- Reuse-in-the-small (libraries of subroutines) began nearly 50 years ago and is a well-solved problem.
  - 库的程序在50年前就开始了。
- Reuse-in-the-large (components) remains a mostly unsolved problem, even though everyone agrees it is important and desirable.
  - 组件式重用，每个人都同意，但很难做到
- Reuse-in-the-large works best in families of related systems and thus is domain-dependent. This narrows the potential applicability of reuse-in-the-large.
  - 组件重用，因其家庭特性，减少了可重用性
- There are two "rules of three" in reuse: (a) It is three times as difficult to build reusable components as single use components, and (b) a reusable component should be tried out in three different applications before it will be sufficiently general to accept into a reuse library.
  - 重用要花三倍时间，组件要适应于三种应用。
- Modification of reused code is particularly error-prone. If more than 20 to 25 percent of a component is to be revised, it is more efficient and effective to rewrite it from scratch.
  - 有25%的重用代码修改，就重写代码吧。
- Design pattern reuse is one solution to the problems inherent in code reuse.
  - 设计模式是不重用的好方法
- For every 25 percent increase in problem complexity, there is a 100 percent increase in complexity of the software solution. That's not a condition to try to change (even though reducing complexity is always a desirable thing to do); that's just the way it is.
  - 25%的问题复杂，100%的项目复杂
- Eighty percent of software work is intellectual. A fair amount of it is creative. Little of it is clerical.
  - 软件工作是智力工作
- 
** about the life
1. One of the two most common causes of runaway projects is unstable requirements.
   1. 失控的项目原因之一是：变动的需求
2. Requirements errors are the most expensive to fix when found during production but the cheapest to fix early in development.
   1. 需求错误应该尽量在开发早期解决
3. Missing requirements are the hardest requirements errors to correct.
   1. 没有需求是最大的需求
4. When moving from requirements to design, there is an explosion of "derived requirements" (the requirements for a particular design solution) caused by the complexity of the solution process. The list of these design requirements is often 50 times longer than the list of original requirements.
   1. 设计需求文档是原始需求的50倍厚
5. There is seldom one best design solution to a software problem
   1. 很少有一个最佳的软件问题解决方案
6. Design is a complex, iterative process. The initial design solution will likely be wrong and certainly not optimal
   1. 设计是一个复杂，迭代的过程
7. Programmers shift from design to coding when the problem is decomposed to a level of "primitives" that the designer has mastered. If the coder is not the same person as the designer, the designer's primitives are unlikely to match the coder's primitives, and trouble will result.
   1. 设计师 ！= 编码者，会产生理解上的问题
8. Error removal is the most time-consuming phase of the life cycle.
   1. 错误排除是最费时间的。
9. Software that a typical programmer believes to be thoroughly tested has often had only about 55 to 60 percent of its logic paths executed. Using automated support, such as coverage analyzers, can raise that roughly to 85 to 90 percent. It is nearly impossible to test software at the level of 100 percent of its logic paths.
   1. 不可能100%的测试
10. Even if 100 percent test coverage were possible, that is not a sufficient criterion for testing. Roughly 35 percent of software defects emerge from missing logic paths, and another 40 percent from the execution of a unique combination of logic paths. They will not be caught by 100 percent coverage.
    1. 
11. It is nearly impossible to do a good job of error removal without tools. Debuggers are commonly used, but others, such as coverage analyzers, are not.
    1. 测试需要工具。
12. Test automation rarely is. That is, certain testing processes can and should be automated. But there is a lot of the testing activity that cannot be automated.
    1. 自动化测试其实很少的。
13. Programmer-created built-in debug code, preferably optionally included in the object code based on compiler parameters, is an important supplement to testing tools.
    1. coder测试的时候最好加入编译器参数调试
14. Rigorous inspections can remove up to 90 percent of errors from a software product before the first test case is run
    1. 严格的检查可以移除90%的错误
15. In spite of the benefits of rigorous inspections, they cannot and should not replace testing
    1. 检查不能，也不应该代替测试
16. Postdelivery reviews (some call them "retrospectives") are generally acknowledged to be important, both from the point of view of determining customer satisfaction and from the point of view of process improvement. But most organizations do not do postdelivery reviews.
    1. postDelivery review 不仅能提高用户满意度，也可以提高软件的工艺水准
17. Peer reviews are both technical and sociological. Paying attention to one without the other is a recipe for disaster
    1. 同行评审很重要
18. Maintenance typically consumes 40 to 80 percent (average, 60 percent) of software costs. Therefore, it is probably the most important life cycle phase of software
    1. 维护占软件开发费用的40% - 80%
19. Enhancement is responsible for roughly 60 percent of software maintenance costs. Error correction is roughly 17 percent. Therefore, software maintenance is largely about adding new capability to old software, not fixing it.
    1. 维护主要是添加新功能，而不是修复它
20. Maintenance is a solution, not a problem.
    1. 维护是一个解决方案不是一个问题
21. In examining the tasks of software development versus software maintenance, most of the tasks are the sameexcept for the additional maintenance task of "understanding the existing product." This task consumes roughly 30 percent of the total maintenance time and is the dominant maintenance activity. Thus it is possible to claim that maintenance is a more difficult task than development.
    1. 维护需要理解产品，因此维护比开发任务更艰巨

** quality
1. Quality is a collection of attributes.
   1. 软件质量是属性的集合（七个属性：可扩展，可移植。。）
2. Quality is not user satisfaction, meeting requirements, meeting cost and schedule targets, or reliability.
   1. 质量 ！= 会议要求 + 需求提供 + 合适的花费
3. There are errors that most programmers tend to make.
   1. 每个程序员都会犯错
4. Errors tend to cluster.
   1. 错误会集聚
5. There is no single best approach to software error removal.
   1. 没有单一的错误排除方法
6. Residual errors will always persist. The goal should be to minimize or eliminate severe errors.
   1. 总会有错误，应该尽量消除严重错误。
7. Efficiency stems more from good design than from good coding.
   1. 高效起源于好的设计，而不是好的Code
8. High-order language (HOL) code, with appropriate compiler optimizations, can be about 90 percent as efficient as the comparable assembler code. Or even higher, for some complex modern architectures.
   1. 
9. There are tradeoffs between size and time optimization. Often, improving one degrades the other
   1. 大软件大小和时效上取舍。
** research
1. Many software researchers advocate rather than investigate. As a result, (a) some advocated concepts are worth far less than their advocates believe, and (b) there is a shortage of evaluative research to help determine what the value of such concepts really is.
   1. 有调查才有发言权，提倡的方法，往往没那么好用。
* Fallacies（这里都是错误的想法）
** management
1. You can't manage what you can't measure.
   1. 不能量测的项目不能管理。
2. You can manage quality into a software product.
   1. 能管理项目的质量
3. Programming can and should be egoless.
   1. 编程应该是无私的。
4. Tools and techniques: one size fits all.
   1. 工具和技术，一刀切
5. Software needs more methodologies
   1. 软件应该采用更多的方法
6. To estimate cost and schedule, first estimate lines of code.
   1. 用代码行数去估计花费和计划
** about the life
1. Random test input is a good way to optimize testing.
   1. 随机测试是一个优化测试的好方法
2. "Given enough eyeballs, all bugs are shallow."
   1. 所有Bug都能测出来
3. The way to predict future maintenance costs and to make product replacement decisions is to look at past cost data
   1. 通过过去的成本数据，去估计现在的维护成本
** education
4. You teach people how to program by showing them how to write programs.
   1. 通过写代码教别人编程。
